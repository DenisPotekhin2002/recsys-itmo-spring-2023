# Отчёт
Лучшим рекоммендером с семинаров был Contextual, поэтому мне показалось логичным взять его за основу и модифицировать, чтобы улучшенный Contextual обогнал свою базовую версию.

Contextual рекомендует трек, похожий на последний прослушанный пользователем, не принимая во внимание время прослушивания этого последнего трека.
Если пользователю не понравится порекомендованная нами песня и он её пропустит, мы всё равно будем рекомендовать похожие треки.

Хотелось бы рекомендовать треки, похожие не на последний прослушанный, а на "высоко оценённый" (долго слушанный) пользователем.

Также хотелось бы не рекомендовать пользователю трек, который он уже слушал, потому что про эту песню он уже всё знает, да и вряд ли захочет слушать по второму кругу.

Для этого я создал рекоммендер MyRec в файле my_rec.py и завёл в нём два словаря: highlyrated и used.
В словаре highlyrated  я храню для каждого пользователя словарь из долго слушанных им треков и чисел, показывающих, сколько раз мы этот трек уже брали для поиска похожего.
Изначально я хотел сортировать этот словарь по упомянутым числам, чтобы не рекомендовать слишком много песен, очень похожих друг на друга.
Если бы для построения рекомендаций мы брали разные треки, была бы некоторая диверсификация, которая могла бы положительно повлиять на время прослушивания пользователем.
Однако я решил, что поддерживать этот словарь отсортированным по значению слишком тяжело и долго, поэтому оставил числа просто для информации, а использовать их для сортировки не стал.
Поэтому можно считать, что в словаре highlyrated просто по каждому пользователю хранятся "высоко оцененные" им треки.

В словаре used для каждого пользователя хранится список треков, которые мы ему уже рекомендовали.

Получая пользователя, предыдущий трек и время прослушивания, в функции recommend_next мы смотрим на время прослушивания - и если оно больше некоторого процента (путём экспериментов я выбрал "барьерный процент" 0,9),
то мы считаем, что это хороший трек (и добавляем его в highlyrated), а если нет, то мы достаём один из треков из списка и считаем хорошим его.

Дальше мы ищем трек, похожий на него, так же, как делали это в Contextual.

Опытным путём я выяснил, что лучше не шафлить рекомендации, а выдавать их подряд (первую ещё не рекомендованную). Наверное, реализация не лучшая, потому что я каждый раз прохожусь по массиву unshuffled с самого начала, хотя мог бы просто хранить индекс,
по которому доставать. Но это было сделано для того, чтобы поэкспериментировать с тем, что лучше, shuffled или unshuffled: после шафла логично было бы проходить по массиву, ища первый не рекомендованный ранее.

Например, при барьерном проценте 0,8 с шафлом средний reward 5,61, а без шафла 6,40 (это при MyRec в Treatment и Contextual в Control).

В качестве fallback-а я взял не Random, а Indexed, потому что если пользователю ничего из прослушанного не понравилось, кажется логичным рекомендовать ему что-то, что нравится таким же критически настроенным пользователям.
А уже если мы совсем ничего не знаем про пользователя, тогда фоллбэк на рандом (хотя, возможно, там логичнее было бы поставить TopPop, но я решил не перегружать рекоммендер двумя различными фоллбэками)

## Эксперимент:
Написав такой рекоммендер, я запустил АВ-эксперимент по сравнению его с Contextual - и получил, что мой рекоммендер лучше на 105%
(при барьерном проценте 0,7 - на 87, при проценте 0,8 - на 88, при проценте 0,9 - на 105). Результаты можно увидеть в юпитер-ноутбуке с первого занятия.
Сейчас там именно этот АВ-эксперимент. Логи в botify/logs.

## Запуск:
Запускается мой рекоммендер так же, как на семинарах (см. README.md):

--episodes 2000 --config config/env.yml multi --processes 2

Код в experiment.py, server.py и my_rec.py.

Если что-то не работает, можно писать мне (vk.com/denispotexin) - я покажу, как запускал сам.